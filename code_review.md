## Code review

В целом все очень хорошо, но есть некоторые комментарии для дальнейшей разработки.

#### GameEngine
Встречаются магические константы, например:
```csharp
GL.ClearColor(0.102f, 0.102f, 0.153f, 1);
```
Лучше сразу выносить такое или в константы или в настраиваемые параметры.

Также как и работу с `gameObj`, `gameObj1` и `gameObj2`.
Их настройку (`Scale`, `Position`, `Rotate`) можно проводить вне `GameEngine` и затем их уже туда передавать.
В самом `GameEngine` лучше тогда сделать массив под эти объекты и просто итеративно их отрисовывать (`Draw`).

#### GameObj
Лучше сделать доступ к `Pipeline` и грамотно настроить их API, чем делать методы-обертки.
Аналогично и для `mesh`, а возможно даже и для `Shader` или в последствии для материала.
Можно даже передавать их в конструктор `GameObj`.

#### Math3D
Перегружен файл. Лучше разбить на отдельные - `vector2`, `vector3`, `Pipeline`, `mPersProj`, `math3d`.
Для `vector2` - нет перегрузок операторов.
Еще хорошо бы добавить конвертацию между `vector2` и `vector3`, много где пригодится.
Вместо `Zero()` лучше сделать набор констант - `Vector3.Zero`, `Vector3.One`, `Vector3.Up`, `Vector3.Left`.

В методе `InitRotateTransform` можно рассчитать заранее math3d.sin(_) и math3d.cos(_) и потом уже присваивать.

Аргументами методов `Rotate`, `Scale` и `Position` лучше сделать сразу `vector3` (иначе в дальнейшем будет множество конвертаций).
Если хочется добавить, например, повороты по конкретным осям, то можно добавить перегрузки - `RotateX`, `RotateY`, `RotateZ`.

`PersProj` - относится к камере.

#### Mesh
Можно выделить часть по конвертации объектов в отдельные классы, которые, например, будут наследоваться от
`IModelFileConverter` с 2-мя методами:
```csharp
bool IsMatching(string file_name);
Mesh Convert(string file_name);
```
Тогда можно будет создать массив (`IModelFileConverter[]`) и докидывать в него реализации под каждый формат моделей.

#### Shader
Можно подумать над:
- Компилирование вне объекта. Сейчас для каждого объекта совершаются одинаковые действия
- Кэшированием шейдеров
- Асинхронная или параллельная компиляция. Если она происходит в рантайме, то она не должна блокировать основной поток

#### Storage
Все также, лучше разбить на отдельные предметные части - шейдеры, модели.

Строковое представление шейдеров лучше поскорее вынести в файлы.
А еще тут можно внести еще одну промежуточную сущность между текстовым файлом и `Shader` - `ShaderFile`.


#### Общий Code style
Названия методов должны отражать **действия**, например `Rotate` - хорошо, а `Position` и `Scale` - уже вызывают сомнения.
Лучше - `SetPosition` или `Move`. Это правило относится к любом коду, но в рамках движка особенно актуально, тк нам важно понимать, совершаем ли мы какое-то действие с объектом.

Стоит проверить постоянство в наименования. Например, что все методы - `CamelCase`.
Аналогично с полями, свойствами и аргументами.

Немного смущает название `Pipeline` для работы с позиционированием.

#### Архитектура
Проект очень интересный и сложный. 
Движки состоят из множества составных частей, решают совершенно разные задачи, а также постоянно расширяются.
Именно поэтому стоит на ранних этапах следить за архитектурой. 
Например, разделение логики. В этом вопросе - лучше создать лишний класс, чем объединять логику в одном громоздком классе.

Также стоит подумать и о том, как будет вестись сама работа с движком.
Сейчас популярным и рабочим походом является - КОП.
И это все также повлияет на все базовые классы - `Mesh`, `Pipeline`.